<!DOCTYPE html>
<html>

<head>
    <title>Histogram</title>
    <style>
    .link {
        stroke: #ccc;
    }

    .node text {
        pointer-events: none;
        font: 14px sans-serif;
        text-color: blue;
    }

    rect.bar {
        fill: hsl(214, 32%, 22%);
    }

    .d3-tip {
        line-height: 1;
        font-weight: bold;
        padding: 12px;
        background: rgba(0, 0, 0, 0.8);
        color: #fff;
        border-radius: 2px;
    }
    /* Creates a small triangle extender for the tooltip */

    .d3-tip:after {
        box-sizing: border-box;
        display: inline;
        font-size: 10px;
        width: 100%;
        line-height: 1;
        color: rgba(0, 0, 0, 0.8);
        content: "\25BC";
        position: absolute;
        text-align: center;
    }
    /* Style northward tooltips differently */

    .d3-tip.n:after {
        margin: -1px 0 0 0;
        top: 100%;
        left: 0;
    }

    .scatterTooltip {
        position: absolute;
        width: 200px;
        height: 28px;
        pointer-events: none;
    }
    </style>
</head>

<body>
    <script src="https://d3js.org/d3.v4.js"></script>
    <script src="https://code.jquery.com/jquery-1.8.2.min.js"></script>
    <script type="application/json" id="mis"></script>
    <div class="options">
        <div class="graphTypeDiv">
            Graph Type:
            <select id="graphType">
                <option value="histBar">Histogram/Bar Chart</option>
                <option value="scatter" selected>Scatter Plot</option>
            </select>
        </div>
        <div class="variableSelectDiv">
	        Variable:
	        <select class="variableSelect"></select>
        </div>
        <div class="numBinsDiv">Number of Bins:
            <input type="number" name="numBins" value="20">
        </div>
        <div class="sortByDiv">
            Sort by:
            <select id="sortBy">
                <option value="alphabetical">Alphabetical</option>
                <option value="countDesc" selected>Count (descending)</option>
                <option value="countAsc">Count (ascending)</option>
            </select>
        </div>
        <div class="scatterOptions">
            X Variable: <select id="xVarSelect"></select>
            <br />
            Y Variable: <select id="yVarSelect"></select>
            <br />
            Color Categorize: <select id="catVarSelect">
                <option value="none">None</option>
            </select>
        </div>
    </div>
    <div class="messages"></div>
    <div>
        <div id="svgContainer" style="width:75%;height:100%;float:left;"></div>
    </div>
    <script type="text/javascript">
    jQuery(document).ready(function() {
        populateHeaderSelect();

        jQuery('.options, input, select').change(function() {
            let graphType = jQuery('#graphType option:selected').val();
            if (graphType === 'histBar') {
                createHistogramWrapper();
            } else if (graphType === 'scatter') {
                createScatterPlotWrapper();
            }
        });

        let graphType = jQuery('#graphType option:selected').val();
        if (graphType === 'histBar') {
            createHistogramWrapper();
        } else if (graphType === 'scatter') {
            createScatterPlotWrapper();
        }
    });

    // Initiate the changing color background
    var backgroundColor = 214;
    var rectInd = 0;
    jQuery(document).ready(function() {
        setInterval(function() {
            rectInd = 0;
            jQuery('rect.bar').each(function() {
                jQuery(this).css('fill',
                    'hsl(' + (backgroundColor + (rectInd++ * 4)) % 360 + ', 32%, 22%)');
            });
            backgroundColor = backgroundColor + 1;

        }, 100);
    });

    var MINIMUM_COLUMN_WIDTH = 60;

    // Global Vars
    var bins = null;
    var margin = null;
    var width = null;
    var height = null;
    var x = null;
    var y = null;
    var height = null;
    var histogram = null;
    var svg = null;
    var histogram = null;
    var variable = null;
    var xVar = null;
    var yVar = null;
    var catVar = null;
    var jsonData = null;
    var isStringData = false;
    var tip = null;

    function createHistogramWrapper() {
        jQuery('.messages').html('');
        jQuery('.sortByDiv').hide();
        jQuery('.scatterOptions').hide();
        jQuery('.variableSelectDiv').show();

        //change "${input0}" to data.txt to test locally
        d3.tsv("${input0}", function(error, data) {
            if (error) throw error;
            jQuery('input').hide();

            variable = jQuery('.variableSelect').val();
            xVar = jQuery('#xVarSelect').val();
            yVar = jQuery('#yVarSelect').val();
            catVar = jQuery('#catVarSelect').val();

            // Get the data in a json format based on the selected variable
            formatDataInJson(data);

            if (!isStringData) {
                //Numeric data, make a normal histogram
                jQuery('.numBinsDiv').show();
                createHistogram();
                bins = histogram(jsonData);
                drawHistogram();
            } else {
                // Make a bar chart since the data is string
                createBarChart();
                jQuery('.numBinsDiv').hide();
                jQuery('.sortByDiv').show();
            }

            jQuery('input').show();
        });

    }

    function createScatterPlotWrapper() {
        jQuery('.messages').html('');
        jQuery('.sortByDiv, .numBinsDiv, .variableSelectDiv').hide();
        jQuery('.scatterOptions').show();

        //change "LearnSphere?htmlPath=workflows/320//Visualization-1-x960916/output/data.txt" to data.txt to test locally
        d3.tsv("${input0}", function(error, data) {
            if (error) throw error;
            jQuery('input').hide();

            xVar = jQuery('#xVarSelect').val();
            yVar = jQuery('#yVarSelect').val();
            catVar = jQuery('#catVarSelect').val();

            // Get the data in a json format based on the selected variable
            formatDataInJson(data);

            createScatterPlot();

            jQuery('input').show();
        });

    }

    function setupGraph() {
        // set the dimensions and margins of the graph
        margin = { top: 10, right: 60, bottom: 60, left: 60 };

        let windowWidth = Math.max(jQuery(window).width(), 600);
        let maxWidth = Math.max(windowWidth, jQuery('input[name="numBins"]').val() * MINIMUM_COLUMN_WIDTH);
        if (isStringData) {
            MINIMUM_COLUMN_WIDTH = widthOfLongestString();
            maxWidth = Math.max(windowWidth, 1.1 * jsonData.length * MINIMUM_COLUMN_WIDTH);
        }
        width = maxWidth - margin.left - margin.right;

        height = jQuery(window).height() * 0.8 - margin.top - margin.bottom;

        if (tip != null) {
            tip.destroy();
            tip = null;
        }

        // Remove previous histogram
        jQuery('#svgContainer').html('');

        // append the svg object to the body of the page
        // append a 'group' element to 'svg'
        // moves the 'group' element to the top left margin
        svg = d3.select("#svgContainer").append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform",
                "translate(" + margin.left + "," + margin.top + ")")
            .call(d3.zoom().on("zoom", zoomed));
    }

    /**
     * Set up histogram functionality
     */
    function createHistogram() {
        let numBins = jQuery('input[name="numBins"]').val();

        setupGraph();

        let xDomain = getDomain();
        x = d3.scaleLinear()
            .range([0, width])
            .domain(xDomain);
        y = d3.scaleLinear()
            .range([height, 0]);

        // set the parameters for the histogram
        histogram = d3.histogram()
            .domain(x.domain())
            .thresholds(x.ticks(numBins));
    }

    function createBarChart() {
        setupGraph();

        // Tooltips
        tip = d3.tip()
            .attr('class', 'd3-tip')
            .offset([-10, 0])
            .html(function(d) {
                return "<strong>Value:</strong> <span style='color:red'>" + d.string + "</span><br/>" +
                    "<strong>Count:</strong> <span style='color:red'>" + d.count + "</span>";
            })
        svg.call(tip);

        // set the ranges
        var x = d3.scaleBand()
            .range([0, width])
            .padding(0.1);
        var y = d3.scaleLinear()
            .range([height, 0]);


        // Scale the range of the data in the domains
        x.domain(jsonData.map(function(d) { return d.string; }));
        y.domain([0, d3.max(jsonData, function(d) { return d.count; })]);

        // append the rectangles for the bar chart
        svg.selectAll("rect")
            .data(jsonData)
            .enter().append("rect")
            .attr("class", "bar")
            .on('mouseover', tip.show)
            .on('mouseout', tip.hide)
            .attr("x", function(d) { return x(d.string); })
            .attr("width", widthOfLongestString()) //x.bandwidth())
            .attr("y", function(d) { return y(d.count); })
            .attr("height", function(d) { return height - y(d.count); });

        // add the x Axis
        svg.append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(x));
        // add a label for x Axis
        svg.append("text")
            .attr("transform",
                "translate(" + (width / 2) + " ," +
                (height + margin.top + 20) + ")")
            .style("text-anchor", "middle")
            .text(variable);
        svg.selectAll(".tick text")
            .call(wrap, widthOfLongestString());

        // add the y Axis
        svg.append("g")
            .call(d3.axisLeft(y));
        // text label for the y axis
        svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", 0 - margin.left)
            .attr("x", 0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .text("Count");
    }

    function createScatterPlot() {
        setupGraph();

        // setup x 
        var xValue = function(d) { return d[xVar]; }, // data -> value
            xScale = d3.scaleLinear().range([0, width]), // value -> display
            xMap = function(d) { return xScale(xValue(d)); }; // data -> display

        // setup y
        var yValue = function(d) { return d[yVar]; }, // data -> value
            yScale = d3.scaleLinear().range([height, 0]), // value -> display
            yMap = function(d) { return yScale(yValue(d)); }; // data -> display

        // setup fill color
        var cValue = null;
        if (catVar !== "none") {
            cValue = function(d) { return d[catVar]; }
        } else {
            cValue = function(d) { return "uncategorized"; }
        }
        //var color = d3.scaleOrdinal(d3.schemeCategory10);
        var color = d3.scaleOrdinal(['#FF0000','#FF7F00','#FFFF00', '#7FFF00', '#00FF00', '#00AF8F', '#0000FF',
        	'#4B0082', '#9400D3', '#000000']);

        // add the tooltip area to the webpage
        var tooltip = d3.select("body").append("div")
            .attr("class", "scatterTooltip")
            .style("opacity", 0);

        // don't want dots overlapping axis, so add in buffer to data domain
        xScale.domain([d3.min(jsonData, xValue) - 1, d3.max(jsonData, xValue) + 1]);
        yScale.domain([d3.min(jsonData, yValue) - 1, d3.max(jsonData, yValue) + 1]);

        // add the x Axis
        svg.append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(xScale));
        // add a label for x Axis
        svg.append("text")
            .attr("transform",
                "translate(" + (width / 2) + " ," +
                (height + margin.top + 20) + ")")
            .style("text-anchor", "middle")
            .text(xVar);

        // add the y Axis
        svg.append("g")
            .call(d3.axisLeft(yScale));
        // text label for the y axis
        svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", 0 - margin.left)
            .attr("x", 0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .text(yVar);

        // draw dots
        svg.selectAll(".dot")
            .data(jsonData)
            .enter().append("circle")
            .attr("class", "dot")
            .attr("r", 3.5)
            .attr("cx", xMap)
            .attr("cy", yMap)
            .style("fill", function(d) { return color(cValue(d)); })
            .on("mouseover", function(d) {
                tooltip.transition()
                    .duration(200)
                    .style("opacity", .9);
                tooltip.html("(" + parseFloat(xValue(d)) +
                        ", " + parseFloat(yValue(d)) + ")")
                    .style("left", (d3.event.pageX + 5) + "px")
                    .style("top", (d3.event.pageY - 28) + "px");
            })
            .on("mouseout", function(d) {
                tooltip.transition()
                    .duration(500)
                    .style("opacity", 0);
            });

        // draw legend
        var legend = svg.selectAll(".legend")
            .data(color.domain())
            .enter().append("g")
            .attr("class", "legend")
            .attr("transform", function(d, i) { return "translate(60," + i * 20 + ")"; });

        // draw legend colored rectangles
        legend.append("rect")
            .attr("x", width - 18)
            .attr("width", 18)
            .attr("height", 18)
            .style("fill", color);

        // draw legend text
        legend.append("text")
            .attr("x", width - 24)
            .attr("y", 9)
            .attr("dy", ".35em")
            .style("text-anchor", "end")
            .text(function(d) { return d; })

    }

    /**
     * function to transform data in json
     */
    function formatDataInJson(data) {
        jsonData = [];
        let numNonNumeric = 0;
        isStringData = false;
        for (let i = 0; i < data.length; i++) {
            let val = data[i][variable];
            if (val != undefined) {
                if (isNaN(val)) {
                    numNonNumeric++;
                }
                jsonData.push(val);
            }
        }

        let graphType = jQuery('#graphType option:selected').val();
        let ratioNonNumeric = numNonNumeric / data.length;
        if (ratioNonNumeric <= 0.5 && numNonNumeric > 0 && graphType === 'histBar') {
            jQuery(".messages").html("This variable has " +
                String(ratioNonNumeric * 100).substring(0, 4) +
                "% non-numeric data." +
                " This histogram will ignore the non-numeric values.");
            let justNumbers = [];
            for (let i = 0; i < jsonData.length; i++) {
                if (!isNaN(jsonData[i])) {
                    justNumbers.push(jsonData[i]);
                }
            }
            jsonData = justNumbers;
        } else if (ratioNonNumeric > 0.5 && graphType === 'histBar') {
            // This is string data
            isStringData = true;
            let stringData = [];
            for (let i = 0; i < jsonData.length; i++) {
                let val = {};
                val.string = jsonData[i];
                val.count = countInArray(jsonData, jsonData[i]);
                stringData.push(val);

                for (var j = jsonData.length - 1; j--;) {
                    if (jsonData[j] === jsonData[i]) {
                        jsonData.splice(j, 1);
                    }
                }
            }
            let sortBy = jQuery('#sortBy option:selected').val();
            if (sortBy === "alphabetical") {
                stringData.sort(
                    function(a, b) {
                        let a1 = a.string,
                            b1 = b.string;
                        if (!isNaN(a.string) && !isNaN(b.string)) {
                            a1 = parseFloat(a.string);
                            b1 = parseFloat(b.string);
                        }
                        return (a1 > b1) ? 1 : ((b1 > a1) ? -1 : 0);
                    });
            } else if (sortBy === "countAsc") {
                stringData.sort(
                    function(a, b) {
                        return (a.count > b.count) ? 1 : ((b.count > a.count) ? -1 : 0);
                    });
            } else if (sortBy === "countDesc") {
                stringData.sort(
                    function(a, b) {
                        return (a.count < b.count) ? 1 : ((b.count < a.count) ? -1 : 0);
                    });
            }
            jsonData = stringData;
        } else if (graphType === "scatter") {
            jsonData = data;
            for (let i = 0; i < jsonData.length; i++) {
	            let valX = jsonData[i][xVar],
	            	valY = jsonData[i][yVar];
	            if (valX != undefined) {
	                if (!isNaN(valX)) {
	                    jsonData[i][xVar] = parseFloat(jsonData[i][xVar]);
	                } else {
	                	jsonData.splice(i--, 1);
	                	continue;
	                }
	            }
	            if (valY != undefined) {
	                if (!isNaN(valY)) {
	                    jsonData[i][yVar] = parseFloat(jsonData[i][yVar]);
	                } else {
	                	jsonData.splice(i--, 1);
	                }
	            }
	        }
        }
    }

    /**
     * Add the data to the histogram
     */
    function drawHistogram() {
        // Tooltips
        tip = d3.tip()
            .attr('class', 'd3-tip')
            .offset([-10, 0])
            .html(function(d) {
                return "<strong>Interval:</strong> <span style='color:red'>" + d.x0 + "-" + d.x1 + "</span><br/>" +
                    "<strong>Count:&nbsp;&nbsp;&nbsp;</strong> <span style='color:red'>" + d.length + "</span>";
            })
        svg.call(tip);

        // Scale the range of the data in the y domain
        y.domain([0, d3.max(bins, function(d) { return d.length; })]);

        // append the bar rectangles to the svg element
        svg.selectAll("rect")
            .data(bins)
            .enter().append("rect")
            .attr("class", "bar")
            .on('mouseover', tip.show)
            .on('mouseout', tip.hide)
            .attr("x", 1)
            .attr("transform", function(d) {
                return "translate(" + x(d.x0) + "," + y(d.length) + ")";
            })
            .attr("width", function(d) {
                return x(d.x1) - x(d.x0) - 1;
            })
            .attr("height", function(d) {
                return height - y(d.length);
            });

        // add the x Axis
        svg.append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(x));
        // add a label for x Axis
        svg.append("text")
            .attr("transform",
                "translate(" + (width / 2) + " ," +
                (height + margin.top + 20) + ")")
            .style("text-anchor", "middle")
            .text(variable);

        // add the y Axis
        svg.append("g")
            .call(d3.axisLeft(y));
    }

    function getDomain() {
        if (!isStringData) {
            return [Math.min(...jsonData), Math.max(...jsonData)];
        } else {
            // probably unnecessary
            let max = -1,
                min = Number.MAX_SAFE_INTEGER;
            for (let i = 0; i < jsonData; i++) {
                let v = jsonData[i].count;
                if (v > max) { max = v; }
                if (v < min) { min = v; }
            }
            return [min, max];
        }
    }

    function populateHeaderSelect() {
        d3.tsv("${input0}", function(error, data) {
            if (error) throw error;
            //gets all column header
            var keys = $.map(data[0], function(item, key) {
                return key;
            });

            keys.forEach(function(key, ind) {
                jQuery('.variableSelect').append(jQuery('<option />').val(key).text(key));
                jQuery('#xVarSelect').append(jQuery('<option />').val(key).text(key));
                if (ind ==1) {
                	jQuery('#yVarSelect').append(jQuery('<option selected />').val(key).text(key));
                } else {
                	jQuery('#yVarSelect').append(jQuery('<option />').val(key).text(key));
                }
                jQuery('#catVarSelect').append(jQuery('<option />').val(key).text(key));
            })
        });
    }

    function countInArray(array, what) {
        var count = 0;
        for (var i = 0; i < array.length; i++) {
            if (array[i] === what) {
                count++;
            }
        }
        return count;
    }

    function wrap(text, width) {
        text.each(function() {

            var text = d3.select(this),
                words = text.text().split(/\s+/).reverse(),
                word,
                line = [],
                lineNumber = 0,
                lineHeight = 1.1, // ems
                y = text.attr("y"),
                dy = parseFloat(text.attr("dy")),
                tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
            let c = 0;
            while (word = words.pop()) {
                line.push(word);
                tspan.text(line.join(" "));
                if (tspan.node().getComputedTextLength() > width && c++ != 0) {
                    line.pop();
                    tspan.text(line.join(" "));
                    line = [word];
                    tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
                }
            }
        });
    }

    function widthOfLongestString() {
        let maxLength = longestString();
        return 6 * maxLength;

    }

    function longestString() {
        let maxLength = -1;
        for (let i = 0; i < jsonData.length; i++) {
            let s = jsonData[i].string;
            let tokens = s.split("\\s+");
            for (let j = 0; j < tokens.length; j++) {
                let t = tokens[j];
                if (t.length > maxLength) {
                    maxLength = t.length;
                }
            }
        }
        return maxLength;
    }

    function zoomed() {
        d3.select("#svgContainer g").attr("transform",
            "translate(" + margin.left + "," + margin.top + ")" +
            "scale(" + d3.event.transform.k + ",1)");
    }

    d3.functor = function functor(v) {
        return typeof v === "function" ? v : function() {
            return v;
        };
    };

    d3.tip = function() {

        var direction = d3_tip_direction,
            offset = d3_tip_offset,
            html = d3_tip_html,
            node = initNode(),
            svg = null,
            point = null,
            target = null

        function tip(vis) {
            svg = getSVGNode(vis)
            point = svg.createSVGPoint()
            document.body.appendChild(node)
        }

        // Public - show the tooltip on the screen
        //
        // Returns a tip
        tip.show = function() {
            var args = Array.prototype.slice.call(arguments)
            if (args[args.length - 1] instanceof SVGElement) target = args.pop()

            var content = html.apply(this, args),
                poffset = offset.apply(this, args),
                dir = direction.apply(this, args),
                nodel = getNodeEl(),
                i = directions.length,
                coords,
                scrollTop = document.documentElement.scrollTop || document.body.scrollTop,
                scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft

            nodel.html(content)
                .style('position', 'absolute')
                .style('opacity', 1)
                .style('pointer-events', 'all')

            while (i--) nodel.classed(directions[i], false)
            coords = direction_callbacks[dir].apply(this)
            nodel.classed(dir, true)
                .style('top', (coords.top + poffset[0]) + scrollTop + 'px')
                .style('left', (coords.left + poffset[1]) + scrollLeft + 'px')

            return tip
        }

        // Public - hide the tooltip
        //
        // Returns a tip
        tip.hide = function() {
            var nodel = getNodeEl()
            nodel
                .style('opacity', 0)
                .style('pointer-events', 'none')
            return tip
        }

        // Public: Proxy attr calls to the d3 tip container.  Sets or gets attribute value.
        //
        // n - name of the attribute
        // v - value of the attribute
        //
        // Returns tip or attribute value
        tip.attr = function(n, v) {
            if (arguments.length < 2 && typeof n === 'string') {
                return getNodeEl().attr(n)
            } else {
                var args = Array.prototype.slice.call(arguments)
                d3.selection.prototype.attr.apply(getNodeEl(), args)
            }

            return tip
        }

        // Public: Proxy style calls to the d3 tip container.  Sets or gets a style value.
        //
        // n - name of the property
        // v - value of the property
        //
        // Returns tip or style property value
        tip.style = function(n, v) {
            // debugger;
            if (arguments.length < 2 && typeof n === 'string') {
                return getNodeEl().style(n)
            } else {
                var args = Array.prototype.slice.call(arguments);
                if (args.length === 1) {
                    var styles = args[0];
                    Object.keys(styles).forEach(function(key) {
                        return d3.selection.prototype.style.apply(getNodeEl(), [key, styles[key]]);
                    });
                }
            }

            return tip
        }

        // Public: Set or get the direction of the tooltip
        //
        // v - One of n(north), s(south), e(east), or w(west), nw(northwest),
        //     sw(southwest), ne(northeast) or se(southeast)
        //
        // Returns tip or direction
        tip.direction = function(v) {
            if (!arguments.length) return direction
            direction = v == null ? v : d3.functor(v)

            return tip
        }

        // Public: Sets or gets the offset of the tip
        //
        // v - Array of [x, y] offset
        //
        // Returns offset or
        tip.offset = function(v) {
            if (!arguments.length) return offset
            offset = v == null ? v : d3.functor(v)

            return tip
        }

        // Public: sets or gets the html value of the tooltip
        //
        // v - String value of the tip
        //
        // Returns html value or tip
        tip.html = function(v) {
            if (!arguments.length) return html
            html = v == null ? v : d3.functor(v)

            return tip
        }

        // Public: destroys the tooltip and removes it from the DOM
        //
        // Returns a tip
        tip.destroy = function() {
            if (node) {
                getNodeEl().remove();
                node = null;
            }
            return tip;
        }

        function d3_tip_direction() { return 'n' }

        function d3_tip_offset() { return [0, 0] }

        function d3_tip_html() { return ' ' }

        var direction_callbacks = {
            n: direction_n,
            s: direction_s,
            e: direction_e,
            w: direction_w,
            nw: direction_nw,
            ne: direction_ne,
            sw: direction_sw,
            se: direction_se
        };

        var directions = Object.keys(direction_callbacks);

        function direction_n() {
            var bbox = getScreenBBox()
            return {
                top: bbox.n.y - node.offsetHeight,
                left: bbox.n.x - node.offsetWidth / 2
            }
        }

        function direction_s() {
            var bbox = getScreenBBox()
            return {
                top: bbox.s.y,
                left: bbox.s.x - node.offsetWidth / 2
            }
        }

        function direction_e() {
            var bbox = getScreenBBox()
            return {
                top: bbox.e.y - node.offsetHeight / 2,
                left: bbox.e.x
            }
        }

        function direction_w() {
            var bbox = getScreenBBox()
            return {
                top: bbox.w.y - node.offsetHeight / 2,
                left: bbox.w.x - node.offsetWidth
            }
        }

        function direction_nw() {
            var bbox = getScreenBBox()
            return {
                top: bbox.nw.y - node.offsetHeight,
                left: bbox.nw.x - node.offsetWidth
            }
        }

        function direction_ne() {
            var bbox = getScreenBBox()
            return {
                top: bbox.ne.y - node.offsetHeight,
                left: bbox.ne.x
            }
        }

        function direction_sw() {
            var bbox = getScreenBBox()
            return {
                top: bbox.sw.y,
                left: bbox.sw.x - node.offsetWidth
            }
        }

        function direction_se() {
            var bbox = getScreenBBox()
            return {
                top: bbox.se.y,
                left: bbox.e.x
            }
        }

        function initNode() {
            var node = d3.select(document.createElement('div'))
            node
                .style('position', 'absolute')
                .style('top', 0)
                .style('opacity', 0)
                .style('pointer-events', 'none')
                .style('box-sizing', 'border-box')

            return node.node()
        }

        function getSVGNode(el) {
            el = el.node()
            if (el.tagName.toLowerCase() === 'svg')
                return el

            return el.ownerSVGElement
        }

        function getNodeEl() {
            if (node === null) {
                node = initNode();
                // re-add node to DOM
                document.body.appendChild(node);
            };
            return d3.select(node);
        }

        // Private - gets the screen coordinates of a shape
        //
        // Given a shape on the screen, will return an SVGPoint for the directions
        // n(north), s(south), e(east), w(west), ne(northeast), se(southeast), nw(northwest),
        // sw(southwest).
        //
        //    +-+-+
        //    |   |
        //    +   +
        //    |   |
        //    +-+-+
        //
        // Returns an Object {n, s, e, w, nw, sw, ne, se}
        function getScreenBBox() {
            var targetel = target || d3.event.target;

            while ('undefined' === typeof targetel.getScreenCTM && 'undefined' === targetel.parentNode) {
                targetel = targetel.parentNode;
            }

            var bbox = {},
                matrix = targetel.getScreenCTM(),
                tbbox = targetel.getBBox(),
                width = tbbox.width,
                height = tbbox.height,
                x = tbbox.x,
                y = tbbox.y

            point.x = x
            point.y = y
            bbox.nw = point.matrixTransform(matrix)
            point.x += width
            bbox.ne = point.matrixTransform(matrix)
            point.y += height
            bbox.se = point.matrixTransform(matrix)
            point.x -= width
            bbox.sw = point.matrixTransform(matrix)
            point.y -= height / 2
            bbox.w = point.matrixTransform(matrix)
            point.x += width
            bbox.e = point.matrixTransform(matrix)
            point.x -= width / 2
            point.y -= height / 2
            bbox.n = point.matrixTransform(matrix)
            point.y += height
            bbox.s = point.matrixTransform(matrix)

            return bbox
        }

        return tip
    };
    </script>
</body>

</html>